// ============================== Рекурсия и стек ==============================

// ======= Рекурсивное вычисление степени числа =======

// Напишите функцию power(x, n), которая возвращает значение x в степени n.

function power(x, n) {
   // Базовый случай рекурсии
   if (n === 0) {
       return 1;
   }
   // Рекурсивный случай: умножаем x на результат функции power с уменьшенной степенью
   return x * power(x, n - 1);
}

// console.log(power(2, 3)); // Выведет 8
// console.log(power(5, 2)); // Выведет 25
// console.log(power(3, 0)); // Выведет 1



// Не смог:
// https://leetcode.com/problems/binary-tree-inorder-traversal/solutions/691488/javascript-clean-solution/
// https://leetcode.com/problems/climbing-stairs/



// Задача: Рекурсивное нахождение максимального элемента в массиве

function findMax(arr) {
    // Базовый случай: если массив содержит один элемент, возвращаем его как максимальный
    if (arr.length === 1) {
        return arr[0];
    }
    // Рекурсивный случай: находим максимальный элемент в оставшейся части массива
    const maxOfRest = findMax(arr.slice(1));
    // Сравниваем первый элемент с максимальным элементом оставшейся части массива
    return arr[0] > maxOfRest ? arr[0] : maxOfRest;
}

// Тестирование функции
console.log(findMax([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])); // Ожидаемый результат: 9
console.log(findMax([10, 20, 30, 5, 15]));              // Ожидаемый результат: 30
console.log(findMax([-10, -20, -30, -5, -15]));         // Ожидаемый результат: -5